% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BSFG_functions.R
\name{get_posterior_FUN}
\alias{get_posterior_FUN}
\title{Calculates the posterior mean of a function of parameters}
\usage{
get_posterior_FUN(BSFG_state, FUN, samples = NULL, mc.cores = detectCores())
}
\arguments{
\item{BSFG_state}{A BSFG_state object including a re-loaded Posterior list}

\item{FUN}{Operations to be applied to each posterior sample. Write as if this were operating
within current_state. Can use priors, data_matrices, and other elements of current_state}

\item{samples}{(optional) vector of sample indexes to use in the computation}

\item{mc.cores}{(optional) number of cores to use for computations. See note about memory requirements.}
}
\value{
array of n_samples x dim1 x dim2 where dim1 and dim2 are the dimensions of the calculated
    parameter per posterior sample
}
\description{
This function will apply the supplied function to each posterior sample of the chain. Variables
   referenced in FUN will be selected from the following search locations (in this order):
   1) Posterior$posteriorSample_params
   2) data_matrices
   3) priors
   4) Posterior$posteriorMean_params
   5) current_state
   6) calling environment (ex. sapply)
   7) global environment
}
\details{
The operations will be parallelized by default. This can cause memory issues. Ideally, make sure
    that the current environment doesn't have very large objects. Alternatively, reduce number
    of cores with \code{mc.cores}, as each fork duplicates the memory of the calling environment (I think).
}
