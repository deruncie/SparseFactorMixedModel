% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BSFG_master.R
\name{BSFG_control}
\alias{BSFG_control}
\title{Set BSFG run parameters}
\usage{
BSFG_control(simulation = c(F, T), scale_Y = c(T, F), K = 20,
  h2_divisions = 100, h2_step_size = NULL, drop0_tol = 1e-14,
  K_eigen_tol = 1e-10, burn = 100, thin = 2, max_NA_groups = Inf,
  svd_K = TRUE, verbose = TRUE, ...)
}
\arguments{
\item{simulation}{Is this a fit to simulated data? If so, a setup list will be expected providing
the true values}

\item{scale_Y}{Should the Y values be centered and scaled? Recommend, except for simulated data.}

\item{K}{number of factors}

\item{h2_divisions}{A scalar or vector of length equal to number of random effects. In BSFG, random
effects are re-scaled as percentages of the total variation. Then a discrete prior spanning [0,1)
with \code{h2_divisions} equally spaced values is constructred for each variance component. If
\code{h2_divisions} is a scalar, the prior for each variance component has this number of divisions.
In the joint prior over all variance components, combinations of variance components with total variance != 1
are assigned a prior of zero and ignored.}

\item{h2_step_size}{Either NULL, or a scaler in the range (0,1] giving specifying the range of h2 values for a Metropolis-Hastings
update step for each h2 parameter vector. If NULL, h2's will be sampled based on the marginal probability
over all possible h2 vectors. If a scalar, a Metropolis-Hastings update step will be used for each h2 vector.
The trail value will be selected uniformly from all possible h2 vectors within this Euclidean distance from the current vector.}

\item{drop0_tol}{A scalar giving the a tolerance for the \code{drop0()} function that will be applied
to various symmetric (possibly) sparse matrices to try to fix numerical errors and increase sparsity.}

\item{K_eigen_tol}{A scalar giving the minimum eigenvalue of a K matrix allowed. During pre-processing,
eigenvalues of each K matrix will be calculated using \code{svd(K)}. Only eigenvectors of K with corresponding eigenvalues
greater than this value will be kept. If smaller eigenvalues exist, the model will be transformed
to reduce the rank of K, by multiplying Z by the remaining eigenvectors of K. This transformation
is undone before posterior samples are recorded, so posterior samples of \code{U_F} and \code{U_R} are
untransformed.}

\item{burn}{burnin length of the MCMC chain}

\item{thin}{thinning rate of the MCMC chain}

\item{max_NA_groups}{If 0, all NAs will be imputed during sampling. If Inf, all NAs will be marginalized over.
If in (0,Inf), up to this many groups of columns will be separately sampled.
The minimum number of NAs in each column not in one of these groups will be imputed.}

\item{svd_K}{If TRUE, the the diagonalization of ZKZt for the first random effect is accomplished using this algorithm:
https://math.stackexchange.com/questions/67231/singular-value-decomposition-of-product-of-matrices which doesn't require forming ZKTt.
If FALSE, the SVD of ZKZt for the first random effect is calculated directly. TRUE is generally faster if the same genomes are repeated several times.}
}
\description{
Function to create run_parameters list for initializing BSFG model
}
\seealso{
\code{\link{BSFG_init}}, \code{\link{sample_BSFG}}, \code{\link{print.BSFG_state}}
}
