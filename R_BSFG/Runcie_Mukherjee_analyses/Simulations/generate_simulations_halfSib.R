#This script prepares sets of simulations to test the model described in Runcie and Mukherjee (2013) Genetics. 
#All simulated data sets described in the paper can be generated by copying the code below. 

library(pedantics)
library(R.matlab)

#This function generates simulated data given a G matrix, a R matrix, an A matrix. Also populates a Matlab struct to hold the simulated latent traits (factors), and other "true" values.
prepare_simulation = function(G_chol,R_chol,A_chol,A,gen_factor_Lambda,error_factor_Lambda,factor_h2s,name){
	#inputs: 
		# G_chol: cholesky decomposition of G-matrix
		# R_chol: cholesky decomposition of R-matrix
		# A_chol: cholesky decomposition of A-matrix (numerator relationship matrix)
		# A: A-matrix (numerator relationship matrix)
		# gen_factor_Lambda: true latent genetic traits that made up G-matrix (to be saved in Matlab struct for diagnostic purposes)
		# error_factor_Lambda: true latent residual traits that made up R-matrix (to be saved in Matlab struct for diagnostic purposes)
		# factor_h2s: true heritabilities of latent factor traits (to be saved in Matlab struct for diagnostic purposes)
		# name: a name to be given to this simulated dataset
	
	n = dim(A_chol)[1]
	p = dim(G_chol)[1]
	
	r = n

	#generate simulated data from MVN. Only genetic and residual effects. No fixed effects
	Y=U_act=E_act=c()
	U_act = t(A_chol) %*% matrix(rnorm(p*r),r,p) %*% G_chol
	E_act = matrix(rnorm(p*n),n,p) %*% R_chol
	Y=rbind(U_act) + E_act  

	#generate appropriate design matrices for half-sib design with a single fixed effect (mean)
	X = matrix(1,nrow=1,ncol=n)
	B = rep(0,p)
	Z_1 = diag(r)[,rep(1:r,n/r)]
	h2 = diag(G)/(diag(G)+diag(R))
		
	print(name)
	writeMat("setup.mat",Y=Y,U_act=U_act,E_act=E_act,Z_1=Z_1,A=A,X=X,n=n,r=r,p=p,gen_factor_Lambda = gen_factor_Lambda,error_factor_Lambda = error_factor_Lambda,h2=h2,G=G,R=R,B=B, factor_h2s=factor_h2s,name=name)
	save(pedigree,file="pedigree.Robj")
}

CovToCor=function(x) diag(1/sqrt(diag(x))) %*% x %*% diag(1/sqrt(diag(x))) 


counter = 0
set.seed(1)

#sample_size simulations
num_reps = 10		# number of simulations to run
p = 100				# number of traits
k=10				# number of latent traits
factor_h2s = seq(1,0,by=-0.1)[1:k]		# heritabilites of latent traits
factor_h2s[seq(1,k,by=2)]=0				# set some latent heritabilities to zero

# list of different sized simulations (#sires,#individuals/sire)
sample_size = list(Small = c(50,5), Medium = c(100,10), Large = c(500,10))


for(size in names(sample_size)[1]){
	nM = sample_size[[size]][1]			# number of sires
	nI = sample_size[[size]][2]			# number of individuals / sire
	pedigree = data.frame(ind=nM*nI + nM + 1:(nM*nI),dam=1:(nM*nI) + nM, sire = gl(nM,nI))		#generate a pedigree for a sire-design
	pedigree<-fixPedigree(pedigree)
	children = !is.na(pedigree[,3])

	#generate A matrix as 2* kinship matrix from whole pedigree
	A = 2*kinship(pedigree[,1], pedigree[,2], pedigree[,3])[children,children]
	A_chol = chol(A)
	for(rep in 1:num_reps){
		counter = counter+1
		
		#generate latent factors. Those with factor_h2s > 0 become genetic factors too. Put these first. Make each factor sparse by only allowing non-zero loadings for p/30 - p/4 of the p traits.
		Lambda = matrix(0,p,k)
		numeff = sample((p/30):(p/4),k,replace=T)
		for(h in 1:k){
			Lambda[sample(1:p,numeff[h]),h] = rnorm(numeff[h])
		}
		Lambda = Lambda[,order(-diag(t(Lambda) %*% Lambda))]
		cols=1:k
		g_cols = factor_h2s>0
		Lambda =Lambda[do.call("order", unname(split(-abs(Lambda[,cols[factor_h2s>0]]), col(Lambda[,cols[factor_h2s>0]])))),]
		
		#make G and R
		G = Lambda %*% diag(factor_h2s) %*% t(Lambda) + 0.2*diag(p)
		R = Lambda %*% diag(1-factor_h2s) %*% t(Lambda) + 0.2*diag(p)
		G_chol = chol(G)
		R_chol = chol(R)
	  
		gen_factor_Lambda = (Lambda %*% diag(sqrt(factor_h2s)))[,factor_h2s>0]
		error_factor_Lambda = Lambda

		name = paste('SampleSize',size,rep,sep='_')
		dir = paste('Sim',counter,sep="_")
		try(dir.create(dir))
		setwd(dir)
		prepare_simulation(G_chol,R_chol,A_chol,A,gen_factor_Lambda,error_factor_Lambda,factor_h2s,name)
		setwd('..')
	}
}

#k simulations
num_reps = 10
p = 100
factor_h2 = 0.5

#number of factors: (#genetic factors with factor_h2>0, #total factors (including the genetic factors))
ks_size = list(Small = c(5,10), Medium = c(15,25), Large = c(30,50))

nM = 100  # number of sires
nI = 10   # of offspring / sire
pedigree = data.frame(ind=nM*nI + nM + 1:(nM*nI),dam=1:(nM*nI) + nM, sire = gl(nM,nI))
pedigree<-fixPedigree(pedigree)
children = !is.na(pedigree[,3])

#generate A matrix as 2* kinship matrix from whole pedigree
A = 2*kinship(pedigree[,1], pedigree[,2], pedigree[,3])[children,children]
A_chol = chol(A)

for(size in names(ks_size)){
	for(rep in 1:num_reps){
		k = ks_size[[size]][2]
		counter = counter+1
		Lambda = matrix(0,p,k)
		numeff = sample((p/30):(p/4),k,replace=T)
		for(h in 1:k){
			Lambda[sample(1:p,numeff[h]),h] = rnorm(numeff[h])
		}
		Lambda = Lambda[,order(-diag(t(Lambda) %*% Lambda))]
		cols=1:k
		factor_h2s = rep(0,k)
		factor_h2s[1:ks_size[[size]][1]] = factor_h2

		G = Lambda %*% diag(factor_h2s) %*% t(Lambda) + 0.2*diag(p)
		R = Lambda %*% diag(1-factor_h2s) %*% t(Lambda) + 0.2*diag(p)
		G_chol = chol(G)
		R_chol = chol(R)
			  
		gen_factor_Lambda = (Lambda %*% diag(sqrt(factor_h2s)))[,factor_h2s>0]
		error_factor_Lambda = Lambda

		name = paste('k',size,rep,sep='_')
		dir = paste('Sim',counter,sep="_")
		try(dir.create(dir))
		setwd(dir)
		prepare_simulation(G_chol,R_chol,A_chol,A,gen_factor_Lambda,error_factor_Lambda,factor_h2s,name)
		setwd('..')
	}
}


#unconstrained R - in these simulations, R is a draw from a wishart distribution and is thus full rank
library(MCMCpack)
num_reps = 10
p = 100
kG = 5   # number of genetic factors

nM = 100
nI = 10
pedigree = data.frame(ind=nM*nI + nM + 1:(nM*nI),dam=1:(nM*nI) + nM, sire = gl(nM,nI))
pedigree<-fixPedigree(pedigree)
children = !is.na(pedigree[,3])
#generate A matrix as 2* kinship matrix from whole pedigree
A = 2*kinship(pedigree[,1], pedigree[,2], pedigree[,3])[children,children]
A_chol = chol(A)

	for(rep in 1:num_reps){
		k = kG
		counter = counter+1
		Lambda = matrix(0,p,k)
		numeff = sample((p/30):(p/4),k,replace=T)
		for(h in 1:k){
			Lambda[sample(1:p,numeff[h]),h] = rnorm(numeff[h])
		}
		Lambda = Lambda[,order(-diag(t(Lambda) %*% Lambda))]
		cols=1:k
		factor_h2s = rep(1,k)
		g_cols = factor_h2s>0
		Lambda =Lambda[do.call("order", unname(split(-abs(Lambda[,cols[factor_h2s>0]]), col(Lambda[,cols[factor_h2s>0]])))),]
		

		G = Lambda %*% diag(factor_h2s) %*% t(Lambda) + 0.2*diag(p)
		R = rwish(p+1,diag(diag(G))/p)
		G_chol = chol(G)
		R_chol = chol(R)
			  
		gen_factor_Lambda = (Lambda %*% diag(sqrt(factor_h2s)))[,factor_h2s>0]
		error_factor_Lambda = Lambda			#really not true latent error factors here.

		name = paste('Rwish',rep,sep='_')
		dir = paste('Sim',counter,sep="_")
		try(dir.create(dir))
		setwd(dir)
		prepare_simulation(G_chol,R_chol,A_chol,A,gen_factor_Lambda,error_factor_Lambda,factor_h2s,name)
		setwd('..')
	}



#non-sparse R - in these simulations, R has a factor structure, but those factors are not sparse
num_reps = 10
p = 100
kG = 5		# number of factors with factor_h2 > 0. These factors are sparse
kR = 5		# number of purely error factors. These factors are not sparse

nM = 100
nI = 10
pedigree = data.frame(ind=nM*nI + nM + 1:(nM*nI),dam=1:(nM*nI) + nM, sire = gl(nM,nI))
pedigree<-fixPedigree(pedigree)
children = !is.na(pedigree[,3])
#generate A matrix as 2* kinship matrix from whole pedigree
A = 2*kinship(pedigree[,1], pedigree[,2], pedigree[,3])[children,children]
A_chol = chol(A)

	for(rep in 1:num_reps){
		k = kG
		counter = counter+1
		Lambda = matrix(0,p,k)
		numeff = sample((p/30):(p/4),k,replace=T)
		for(h in 1:k){
			Lambda[sample(1:p,numeff[h]),h] = rnorm(numeff[h])
		}
		Lambda = Lambda[,order(-diag(t(Lambda) %*% Lambda))]
		cols=1:k
		factor_h2s = rep(0.5,k)
		g_cols = factor_h2s>0
		Lambda =Lambda[do.call("order", unname(split(-abs(Lambda[,cols[factor_h2s>0]]), col(Lambda[,cols[factor_h2s>0]])))),]
		
		Lambda = cbind(Lambda,matrix(rnorm(kR*p),p,kR))
		factor_h2s = c(factor_h2s,rep(0,kR))
		

		G = Lambda %*% diag(factor_h2s) %*% t(Lambda) + 0.2*diag(p)
		R = Lambda %*% diag(1-factor_h2s) %*% t(Lambda) + 0.2*diag(p)
		G_chol = chol(G)
		R_chol = chol(R)
		  
		gen_factor_Lambda = (Lambda %*% diag(sqrt(factor_h2s)))[,factor_h2s>0]
		error_factor_Lambda = Lambda

		name = paste('R_notSparse',rep,sep='_')
		dir = paste('Sim',counter,sep="_")
		try(dir.create(dir))
		setwd(dir)
		prepare_simulation(G_chol,R_chol,A_chol,A,gen_factor_Lambda,error_factor_Lambda,factor_h2s,name)
		setwd('..')
	}



#p simulations - these simulations alter the number of traits
num_reps = 10
factor_h2 = 0.5
k = 10		#total latent factors
k_G = 5		# number of latent factors with factor_h2 > 0

#number of traits
ks_size = list(Small = 20, Large = 1000)

nM = 100
nI = 10
pedigree = data.frame(ind=nM*nI + nM + 1:(nM*nI),dam=1:(nM*nI) + nM, sire = gl(nM,nI))
pedigree<-fixPedigree(pedigree)
children = !is.na(pedigree[,3])
#generate A matrix as 2* kinship matrix from whole pedigree
A = 2*kinship(pedigree[,1], pedigree[,2], pedigree[,3])[children,children]
A_chol = chol(A)

for(size in names(ks_size)){
	for(rep in 1:num_reps){
		p = ks_size[[size]]
		counter = counter+1
		Lambda = matrix(0,p,k)
		numeff = sample((p/30):(p/4),k,replace=T)
		numeff[numeff<3]=3
		for(h in 1:k){
			Lambda[sample(1:p,numeff[h]),h] = rnorm(numeff[h])
		}
		Lambda = Lambda[,order(-diag(t(Lambda) %*% Lambda))]
		cols=1:k
		factor_h2s = rep(0,k)
		factor_h2s[1:k_G] = factor_h2
	
		G = Lambda %*% diag(factor_h2s) %*% t(Lambda) + 0.2*diag(p)
		R = Lambda %*% diag(1-factor_h2s) %*% t(Lambda) + 0.2*diag(p)
		G_chol = chol(G)
		R_chol = chol(R)
		  
		gen_factor_Lambda = (Lambda %*% diag(sqrt(factor_h2s)))[,factor_h2s>0]
		error_factor_Lambda = Lambda

		name = paste('p',size,rep,sep='_')
		dir = paste('Sim',counter,sep="_")
		try(dir.create(dir))
		setwd(dir)
		prepare_simulation(G_chol,R_chol,A_chol,A,gen_factor_Lambda,error_factor_Lambda,factor_h2s,name)
		setwd('..')
	}
}

